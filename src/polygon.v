(*
    Давайте выкинем неспецифицированные случаи, потому что с ними очень тяжко осознать что нужно

    Идея следующая: нужно взять некоторое множество состояний, задать на них отношение 
    (которое как-то должно соответствовать функциям контракта). Потом написать 
    рекурсивную функцию, которая будет проходить по состояниям (видимо по коиндуктивному листу)
    И проверять заранее написанную лтл формулу 
    Возможно эти листы надо как-то хитро строить с предусловиями, но это пока не понятно

    Нам не нужен оператор некст, потому что это и есть экзеки и евалы, которые задаются
    отношениям. Вероятно нам нужны только файнали, глобали и антил.
    Если нам точно нужно следить за одной переменной, то нам нужно будет добавить ее в состояние
    Тогда, возможно, нам придется таскать много переменны, что мне не нравится
    Надо написать инд проп про корректность состояний


    Сейчас надо более явно написать состояния и написать инд проп для лтл.
    *)

    Require Import List.
    Require Import Lia.
    Import ListNotations.
    Variable (state : Set).
    
    Variables (A : state) (D : state) (B : state) (C : state).
    
    Inductive rel : state -> state -> Prop := 
    | AC : rel A C
    | AB : rel A B
    | BC : rel B C
    | AD : rel A D.
    (* G phi /\ F psi /\ phi U psi *)
    
    Inductive rel_prop : list state -> Prop :=
    | cons1 : rel_prop []
    | cons2 : forall a, rel_prop [a]
    | cons3 : forall a b l , rel a b -> rel_prop (b :: l) -> rel_prop (a :: b :: l).
    
    Definition scen1 := [ A ; B ; C ].
    Definition scen2 := [ C ; D ].
    
    Lemma scen1_correct : rel_prop scen1.
    Proof.
        repeat constructor.
    Qed.
    
    
    (* rel C D
    Abort. *)